/**
 * Copyright 2023 Neckar IT GmbH, MÃ¶ssingen, Germany
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.meistercharts.history.downsampling

import assertk.*
import assertk.assertions.*
import com.meistercharts.history.HistoryBucketDescriptor
import com.meistercharts.history.HistoryEnumSet
import com.meistercharts.history.InMemoryHistoryStorage
import com.meistercharts.history.ReferenceEntryDataSeriesIndex
import com.meistercharts.history.ReferenceEntryDifferentIdsCount
import com.meistercharts.history.ReferenceEntryId
import com.meistercharts.history.SamplingPeriod
import com.meistercharts.history.TimestampIndex
import com.meistercharts.history.generator.HistoryChunkGenerator
import com.meistercharts.history.generator.ReferenceEntryGenerator
import com.meistercharts.history.impl.timeRange
import com.meistercharts.history.isCountPending
import com.meistercharts.history.isEnumSetPending
import com.meistercharts.history.isEqualToHistoryEnumSet
import com.meistercharts.history.isEqualToReferenceEntryId
import com.meistercharts.history.isEqualToReferenceEntryIdsCount
import com.meistercharts.time.TimeRange
import com.meistercharts.time.TimeRanges
import it.neckar.datetime.minimal.TimeConstants
import it.neckar.open.formatting.formatUtc
import it.neckar.open.test.utils.RandomWithSeed
import it.neckar.open.unit.si.ms
import org.junit.jupiter.api.Test
import kotlin.time.Duration.Companion.hours
import kotlin.time.Duration.Companion.milliseconds
import kotlin.time.Duration.Companion.seconds

class DownSamplingReferenceEntriesTest {
  @Test
  fun test45s() {
    val historyStorage = InMemoryHistoryStorage()

    val samplingPeriod = SamplingPeriod.EveryHundredMillis
    val samplingPeriodAbove = requireNotNull(samplingPeriod.above())

    val chunkGenerator = HistoryChunkGenerator(
      historyStorage = historyStorage,
      samplingPeriod = samplingPeriod,
      decimalValueGenerators = emptyList(),
      enumValueGenerators = emptyList(),
      referenceEntryGenerators = List(3) {
        ReferenceEntryGenerator.increasing(45.seconds)
      },
      referenceEntryStatusProvider = { _: ReferenceEntryId, millis: @ms Double ->
        if ((millis / samplingPeriod.distance / 2.0) % 1 > 0.5) {
          HistoryEnumSet.first
        } else {
          HistoryEnumSet.second
        }
      }
    )

    chunkGenerator.historyConfiguration.referenceEntryConfiguration.getStatusEnum(ReferenceEntryDataSeriesIndex.zero).let {
      requireNotNull(it)
      //Automatically generated by createDefaultHistoryConfiguration()
      assertThat(it.enumDescription).isEqualTo("Active")
    }

    historyStorage.downSamplingService.dirtyRangesCollector.observe(historyStorage)

    val start = 1777777896777.0
    assertThat(start.formatUtc()).isEqualTo("2026-05-03T03:11:36.777Z")
    val chunk = requireNotNull(chunkGenerator.forTimeRange(TimeRange.fromStartAndDuration(start, 1.hours)))

    assertThat(chunk.firstTimestamp.formatUtc()).isEqualTo(start.formatUtc())


    historyStorage.storeWithoutCache(chunk, samplingPeriod)
    historyStorage.downSamplingService.calculateDownSamplingIfRequired()


    //Recorded
    historyStorage.get(HistoryBucketDescriptor.forTimestamp(start, samplingPeriod.toHistoryBucketRange())).let { bucket ->
      requireNotNull(bucket)
      assertThat(bucket.chunk.timestampCenter(TimestampIndex.zero).formatUtc()).isEqualTo("2026-05-03T03:11:36.777Z")
      assertThat(bucket.chunk.timeStampsCount).isEqualTo(233)
      assertThat(bucket.chunk.lastTimeStamp().formatUtc()).isEqualTo("2026-05-03T03:11:59.977Z")

      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.zero)).isEqualToReferenceEntryId(6175)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.one)).isEqualToReferenceEntryId(6175)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(77))).isEqualToReferenceEntryId(6175)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, bucket.chunk.lastTimeStampIndex())).isEqualToReferenceEntryId(6175)

      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(2))).isEqualToReferenceEntryIdsCount(1)

      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualToHistoryEnumSet(0b01)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEqualToHistoryEnumSet(0b10)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(2))).isEqualToHistoryEnumSet(0b01)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, bucket.chunk.lastTimeStampIndex())).isEqualToHistoryEnumSet(0b01)
    }

    //Recorded, but later
    historyStorage.get(HistoryBucketDescriptor.forTimestamp(start + 45 * 1000, samplingPeriod.toHistoryBucketRange())).let { bucket ->
      requireNotNull(bucket)
      assertThat(bucket.chunk.timestampCenter(TimestampIndex.zero).formatUtc()).isEqualTo("2026-05-03T03:12:00.077Z")
      assertThat(bucket.chunk.timeStampsCount).isEqualTo(600)
      assertThat(bucket.chunk.lastTimeStamp().formatUtc()).isEqualTo("2026-05-03T03:12:59.977Z")

      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.zero)).isEqualToReferenceEntryId(6176)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.one)).isEqualToReferenceEntryId(6176)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(77))).isEqualToReferenceEntryId(6176)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, bucket.chunk.lastTimeStampIndex())).isEqualToReferenceEntryId(6177)

      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(2))).isEqualToReferenceEntryIdsCount(1)

      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualToHistoryEnumSet(0b10)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEqualToHistoryEnumSet(0b01)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(2))).isEqualToHistoryEnumSet(0b10)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, bucket.chunk.lastTimeStampIndex())).isEqualToHistoryEnumSet(0b01)
    }

    //Verify down sampled (1s)

    historyStorage.get(HistoryBucketDescriptor.forTimestamp(start, samplingPeriodAbove.toHistoryBucketRange())).let { bucket ->
      requireNotNull(bucket)
      if (false) {
        println(bucket.chunk.dump())
      }

      assertThat(bucket.samplingPeriod).isEqualTo(SamplingPeriod.EverySecond)

      assertThat(bucket.chunk.timestampCenter(TimestampIndex.zero).formatUtc()).isEqualTo("2026-05-03T03:10:00.500Z")
      assertThat(bucket.chunk.timeStampsCount).isEqualTo(600)
      assertThat(bucket.chunk.firstTimestamp.formatUtc()).isEqualTo("2026-05-03T03:10:00.500Z")
      assertThat(bucket.chunk.lastTimestamp.formatUtc()).isEqualTo("2026-05-03T03:19:59.500Z")


      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualTo(ReferenceEntryId.Pending)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(599))).isEqualToReferenceEntryId(6186)

      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualTo(ReferenceEntryDifferentIdsCount.Pending)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(250))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(300))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(350))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(599))).isEqualToReferenceEntryIdsCount(1)


      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEnumSetPending()
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEnumSetPending()
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(300))).isEqualToHistoryEnumSet(0b11)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(350))).isEqualToHistoryEnumSet(0b11)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(599))).isEqualToHistoryEnumSet(0b11)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, bucket.chunk.lastTimeStampIndex())).isEqualToHistoryEnumSet(0b11)
    }

    // Next level (10s)

    historyStorage.get(HistoryBucketDescriptor.forTimestamp(start, samplingPeriodAbove.above()!!.toHistoryBucketRange())).let { bucket ->
      requireNotNull(bucket)
      if (false) {
        println(bucket.chunk.dump())
      }

      assertThat(bucket.samplingPeriod).isEqualTo(SamplingPeriod.EveryTenSeconds)

      assertThat(bucket.chunk.timestampCenter(TimestampIndex.zero).formatUtc()).isEqualTo("2026-05-03T03:00:05.000Z")
      assertThat(bucket.chunk.timeStampsCount).isEqualTo(360)
      assertThat(bucket.chunk.firstTimestamp.formatUtc()).isEqualTo("2026-05-03T03:00:05.000Z")
      assertThat(bucket.chunk.lastTimestamp.formatUtc()).isEqualTo("2026-05-03T03:59:55.000Z")


      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualTo(ReferenceEntryId.Pending)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(359))).isEqualToReferenceEntryId(6239)

      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualTo(ReferenceEntryDifferentIdsCount.Pending)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(359))).isEqualToReferenceEntryIdsCount(1)

      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(250))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(300))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(350))).isEqualToReferenceEntryIdsCount(1)


      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEnumSetPending()
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEnumSetPending()
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(300))).isEqualToHistoryEnumSet(0b11)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(350))).isEqualToHistoryEnumSet(0b11)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(359))).isEqualToHistoryEnumSet(0b11)
    }

    //Next Layer (1 min)
    historyStorage.get(HistoryBucketDescriptor.forTimestamp(start, samplingPeriodAbove.above()?.above()!!.toHistoryBucketRange())).let { bucket ->
      requireNotNull(bucket)
      if (false) {
        println(bucket.chunk.dump())
      }

      assertThat(bucket.samplingPeriod).isEqualTo(SamplingPeriod.EveryMinute)
      assertThat(bucket.chunk.firstTimestamp.formatUtc()).isEqualTo("2026-05-03T00:00:30.000Z")
      assertThat(bucket.chunk.lastTimestamp.formatUtc()).isEqualTo("2026-05-03T05:59:30.000Z")
      assertThat(bucket.chunk.timeStampsCount).isEqualTo(360)
      assertThat(bucket.chunk.timestampCenter(TimestampIndex.zero).formatUtc()).isEqualTo("2026-05-03T00:00:30.000Z")


      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualTo(ReferenceEntryId.Pending)
      assertThat(bucket.chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(191))).isEqualToReferenceEntryId(6175)

      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isCountPending()
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(191))).isEqualToReferenceEntryIdsCount(1)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(192))).isEqualToReferenceEntryIdsCount(3)
      assertThat(bucket.chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(359))).isCountPending()

      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEnumSetPending()
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEnumSetPending()
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(191))).isEqualToHistoryEnumSet(0b11)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(192))).isEqualToHistoryEnumSet(0b11)
      assertThat(bucket.chunk.getReferenceEntryStatus(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(359))).isEnumSetPending()
    }
  }

  @Test
  fun testSameValue() {
    val historyStorage = InMemoryHistoryStorage()

    val samplingPeriod = SamplingPeriod.EveryHundredMillis
    val samplingPeriodAbove = requireNotNull(samplingPeriod.above())

    val chunkGenerator = HistoryChunkGenerator(
      historyStorage = historyStorage,
      samplingPeriod = samplingPeriod,
      decimalValueGenerators = emptyList(),
      enumValueGenerators = emptyList(),
      referenceEntryGenerators = List(1) {
        ReferenceEntryGenerator.always(ReferenceEntryId(45))
      },
    )

    val generated = chunkGenerator.forTimeRange(TimeRange.oneMinuteSinceReference)
    requireNotNull(generated)

    assertThat(generated.timeRange()).isEqualTo(TimeRange(TimeConstants.referenceTimestamp, TimeConstants.referenceTimestamp + 60_000 - 100)) //plus 1 minute, minus the last entry
    assertThat(generated.firstTimestamp.formatUtc()).isEqualTo("2024-01-01T00:00:00.000Z") //plus 1 minute, minus the last entry
    assertThat(generated.lastTimestamp.formatUtc()).isEqualTo("2024-01-01T00:00:59.900Z") //plus 1 minute, minus the last entry


    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.one)).isEqualToReferenceEntryId(45)
    assertThat(generated.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.one).value).isEqualTo(1)

    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()

    historyStorage.downSamplingService.dirtyRangesCollector.observe(historyStorage)
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()

    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).isEmpty()
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriodAbove)).isEmpty()
    historyStorage.storeWithoutCache(generated, samplingPeriod)
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).hasSize(1)
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriodAbove)).isEmpty() //no down sampling!

    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[SamplingPeriod.EverySecond]).isEqualTo(TimeRanges.of(generated.timeRange()))

    historyStorage.downSamplingService.calculateDownSamplingIfRequired()

    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[SamplingPeriod.EverySecond]).isNull() //not dirty anymore

    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).hasSize(1)
    val downSampled = historyStorage.query(generated.timeRange(), samplingPeriodAbove)
    assertThat(downSampled).hasSize(1) //down sampling has been calculated

    downSampled.first().let { bucket ->
      assertThat(bucket.start.formatUtc()).isEqualTo("2024-01-01T00:00:00.000Z")
      assertThat(bucket.end.formatUtc()).isEqualTo("2024-01-01T00:10:00.000Z")

      val chunk = bucket.chunk
      val timestampIndex = TimestampIndex(chunk.bestTimestampIndexFor(generated.firstTimestamp).nearIndex)

      assertThat(chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, timestampIndex)).isEqualToReferenceEntryId(45)
      assertThat(chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, timestampIndex)).isEqualToReferenceEntryIdsCount(1)
    }
  }

  @Test
  @RandomWithSeed
  fun testRandomGenerator() {
    val historyStorage = InMemoryHistoryStorage()

    val samplingPeriod = SamplingPeriod.EveryHundredMillis
    val samplingPeriodAbove = requireNotNull(samplingPeriod.above())

    val chunkGenerator = HistoryChunkGenerator(
      historyStorage = historyStorage,
      samplingPeriod = samplingPeriod,
      decimalValueGenerators = emptyList(),
      enumValueGenerators = emptyList(),
      referenceEntryGenerators = List(3) {
        ReferenceEntryGenerator.random()
      },
    )

    val generated = chunkGenerator.forTimeRange(TimeRange.oneMinuteSinceReference)
    requireNotNull(generated)

    assertThat(generated.timeRange()).isEqualTo(TimeRange(TimeConstants.referenceTimestamp, TimeConstants.referenceTimestamp + 60_000 - 100)) //plus 1 minute, minus the last entry
    assertThat(generated.firstTimestamp.formatUtc()).isEqualTo("2024-01-01T00:00:00.000Z") //plus 1 minute, minus the last entry
    assertThat(generated.lastTimestamp.formatUtc()).isEqualTo("2024-01-01T00:00:59.900Z") //plus 1 minute, minus the last entry


    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.one)).isEqualToReferenceEntryId(17667)
    assertThat(generated.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.one).value).isEqualTo(1)


    //Down sampling
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()

    historyStorage.downSamplingService.dirtyRangesCollector.observe(historyStorage)
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()

    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).isEmpty()
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriodAbove)).isEmpty()
    historyStorage.storeWithoutCache(generated, samplingPeriod)
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).hasSize(1)
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriodAbove)).isEmpty() //no down sampling!

    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[SamplingPeriod.EverySecond]).isEqualTo(TimeRanges.of(generated.timeRange()))

    historyStorage.downSamplingService.calculateDownSamplingIfRequired()

    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[SamplingPeriod.EverySecond]).isNull() //not dirty anymore

    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).hasSize(1)
    val downSampled = historyStorage.query(generated.timeRange(), samplingPeriodAbove)
    assertThat(downSampled).hasSize(1) //down sampling has been calculated

    downSampled.first().let { bucket ->
      assertThat(bucket.start.formatUtc()).isEqualTo("2024-01-01T00:00:00.000Z")
      assertThat(bucket.end.formatUtc()).isEqualTo("2024-01-01T00:10:00.000Z")

      val chunk = bucket.chunk
      val timestampIndex = TimestampIndex(chunk.bestTimestampIndexFor(generated.firstTimestamp).nearIndex)

      assertThat(chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.one, timestampIndex)).isEqualToReferenceEntryId(82032)
      assertThat(chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.one, timestampIndex)).isEqualToReferenceEntryIdsCount(10)
    }
  }

  @Test
  @RandomWithSeed
  fun testIncreasingGenerator() {
    val historyStorage = InMemoryHistoryStorage()

    val samplingPeriod = SamplingPeriod.EveryHundredMillis
    val samplingPeriodAbove = requireNotNull(samplingPeriod.above())

    val chunkGenerator = HistoryChunkGenerator(
      historyStorage = historyStorage,
      samplingPeriod = samplingPeriod,
      decimalValueGenerators = emptyList(),
      enumValueGenerators = emptyList(),
      referenceEntryGenerators = List(3) {
        ReferenceEntryGenerator.increasing(500.milliseconds)
      },
    )

    val generated = chunkGenerator.forTimeRange(TimeRange.oneMinuteSinceReference)
    requireNotNull(generated)

    assertThat(generated.timeRange()).isEqualTo(TimeRange(TimeConstants.referenceTimestamp, TimeConstants.referenceTimestamp + 60_000 - 100)) //plus 1 minute, minus the last entry
    assertThat(generated.firstTimestamp.formatUtc()).isEqualTo("2024-01-01T00:00:00.000Z") //plus 1 minute, minus the last entry
    assertThat(generated.lastTimestamp.formatUtc()).isEqualTo("2024-01-01T00:00:59.900Z") //plus 1 minute, minus the last entry

    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(0))).isEqualToReferenceEntryId(34400)
    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(1))).isEqualToReferenceEntryId(34400)
    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(3))).isEqualToReferenceEntryId(34400)
    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(4))).isEqualToReferenceEntryId(34400)
    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(5))).isEqualToReferenceEntryId(34401)
    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(8))).isEqualToReferenceEntryId(34401)
    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(9))).isEqualToReferenceEntryId(34401)
    assertThat(generated.getReferenceEntryId(ReferenceEntryDataSeriesIndex.zero, TimestampIndex(10))).isEqualToReferenceEntryId(34402)
    assertThat(generated.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.zero, TimestampIndex.one).value).isEqualTo(1)


    //Down sampling
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()

    historyStorage.downSamplingService.dirtyRangesCollector.observe(historyStorage)
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()

    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).isEmpty()
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriodAbove)).isEmpty()
    historyStorage.storeWithoutCache(generated, samplingPeriod)
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).hasSize(1)
    assertThat(historyStorage.query(generated.timeRange(), samplingPeriodAbove)).isEmpty() //no down sampling!

    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[SamplingPeriod.EverySecond]).isEqualTo(TimeRanges.of(generated.timeRange()))

    historyStorage.downSamplingService.calculateDownSamplingIfRequired()

    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[samplingPeriod]).isNull()
    assertThat(historyStorage.downSamplingService.dirtyRangesCollector[SamplingPeriod.EverySecond]).isNull() //not dirty anymore

    assertThat(historyStorage.query(generated.timeRange(), samplingPeriod)).hasSize(1)
    val downSampled = historyStorage.query(generated.timeRange(), samplingPeriodAbove)
    assertThat(downSampled).hasSize(1) //down sampling has been calculated

    downSampled.first().let { bucket ->
      assertThat(bucket.start.formatUtc()).isEqualTo("2024-01-01T00:00:00.000Z")
      assertThat(bucket.end.formatUtc()).isEqualTo("2024-01-01T00:10:00.000Z")

      val chunk = bucket.chunk
      val timestampIndex = TimestampIndex(chunk.bestTimestampIndexFor(generated.firstTimestamp).nearIndex)
      assertThat(timestampIndex).isEqualTo(TimestampIndex(0))

      assertThat(chunk.getReferenceEntryId(ReferenceEntryDataSeriesIndex.one, timestampIndex)).isEqualToReferenceEntryId(34400)
      assertThat(chunk.getReferenceEntryIdsCount(ReferenceEntryDataSeriesIndex.one, timestampIndex)).isEqualToReferenceEntryIdsCount(2)
    }
  }
}
